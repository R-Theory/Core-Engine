sequenceDiagram
    participant U as User
    participant FE as Frontend (Next.js)
    participant API as Backend API (FastAPI)
    participant Auth as AuthService
    participant DB as PostgreSQL
    participant Cache as Redis
    participant PE as PluginEngine
    participant AO as AgentOrchestrator
    participant WE as WorkflowEngine
    participant CP as CanvasPlugin
    participant MA as MetaGPTAgent

    %% User Authentication Flow
    Note over U, MA: Authentication & Initial Setup
    U->>FE: Navigate to login page
    FE->>U: Display login form
    U->>FE: Submit credentials (email, password)
    FE->>API: POST /api/v1/auth/login
    API->>Auth: authenticate_user(email, password)
    Auth->>DB: SELECT user WHERE email=? AND password_hash=?
    DB-->>Auth: User record
    Auth->>Auth: verify_password(password, hash)
    Auth->>Auth: create_access_token(user_data)
    Auth->>Auth: create_refresh_token(user_data)
    Auth-->>API: TokenResponse(access_token, refresh_token)
    API-->>FE: 200 OK {tokens, user_info}
    FE->>FE: store_tokens_securely()
    FE->>U: Redirect to dashboard

    %% Dashboard Data Loading
    Note over U, MA: Dashboard Initialization
    U->>FE: Access dashboard
    FE->>API: GET /api/v1/courses (with auth header)
    API->>Auth: get_current_user(token)
    Auth-->>API: User object
    API->>Cache: get("courses:user_123")
    Cache-->>API: null (cache miss)
    API->>DB: SELECT courses WHERE user_id=?
    DB-->>API: List[Course]
    API->>Cache: set("courses:user_123", courses, ttl=1800)
    API-->>FE: 200 OK List[Course]
    
    FE->>API: GET /api/v1/resources?limit=10
    API->>DB: SELECT resources WHERE user_id=? ORDER BY created_at DESC LIMIT 10
    DB-->>API: List[Resource]
    API-->>FE: 200 OK List[Resource]
    
    FE->>API: GET /api/v1/workflows
    API->>DB: SELECT workflows WHERE user_id=? AND is_active=true
    DB-->>API: List[Workflow]
    API-->>FE: 200 OK List[Workflow]
    
    FE->>FE: render_dashboard(courses, resources, workflows)
    FE->>U: Display populated dashboard

    %% Plugin Installation and Configuration
    Note over U, MA: Plugin Management
    U->>FE: Navigate to plugin settings
    U->>FE: Click "Install Canvas Plugin"
    FE->>U: Display plugin installation form
    U->>FE: Submit Canvas domain and OAuth consent
    FE->>API: POST /api/v1/plugins/install
    API->>PE: load_plugin_manifest("canvas-integration")
    PE->>PE: validate_manifest(manifest)
    PE->>DB: INSERT INTO plugins (user_id, name, version, config)
    DB-->>PE: Plugin record created
    
    API->>CP: authenticate(oauth_credentials)
    CP->>CP: oauth2_flow(canvas_domain, credentials)
    CP-->>API: Authentication successful
    
    API->>DB: UPDATE plugins SET encrypted_credentials=? WHERE id=?
    API-->>FE: 201 Created {plugin_info}
    FE->>U: Display "Plugin installed successfully"

    %% Course Data Synchronization
    Note over U, MA: External Data Sync
    U->>FE: Click "Sync Canvas Data"
    FE->>API: POST /api/v1/plugins/canvas-integration/execute
    API->>PE: execute_plugin_action("canvas-integration", "get_courses", params)
    PE->>CP: get_courses()
    CP->>CP: make_api_request("GET", "/api/v1/courses")
    CP-->>PE: List[CanvasCourse]
    PE-->>API: PluginExecutionResult(success=true, data=courses)
    
    API->>API: transform_canvas_courses_to_internal(courses)
    loop For each Canvas course
        API->>DB: INSERT INTO courses (user_id, name, code, external_id) ON CONFLICT UPDATE
        DB-->>API: Course record
        
        API->>PE: execute_plugin_action("canvas-integration", "get_assignments", {course_id})
        PE->>CP: get_assignments(course_id)
        CP-->>PE: List[CanvasAssignment]
        
        loop For each assignment
            API->>DB: INSERT INTO assignments (course_id, title, due_date, external_id) ON CONFLICT UPDATE
            DB-->>API: Assignment record
        end
    end
    
    API->>Cache: invalidate_pattern("courses:user_123*")
    API-->>FE: 200 OK {synced_courses: 5, synced_assignments: 23}
    FE->>U: Display sync results

    %% AI Agent Processing
    Note over U, MA: AI-Powered Analysis
    U->>FE: Select assignment "CS101 Final Project"
    U->>FE: Click "Analyze with AI"
    FE->>API: POST /api/v1/agents/claude/process
    API->>AO: execute_single_agent("claude", request)
    AO->>MA: process(AgentRequest)
    MA->>MA: validate_request(request)
    MA->>MA: prepare_api_call(prompt, context)
    MA->>MA: call_claude_api(processed_prompt)
    MA-->>AO: AgentResponse(success=true, content=analysis, cost=0.15)
    AO-->>API: AgentResponse
    
    API->>DB: INSERT INTO ai_analyses (assignment_id, agent_type, analysis, cost)
    DB-->>API: Analysis record created
    API-->>FE: 200 OK {analysis, cost, execution_time}
    FE->>FE: render_ai_analysis(analysis)
    FE->>U: Display AI analysis results

    %% Workflow Creation and Execution
    Note over U, MA: Workflow Automation
    U->>FE: Navigate to workflow builder
    U->>FE: Create "Weekly Assignment Summary" workflow
    FE->>FE: visual_workflow_builder.add_step("plugin_action", canvas_plugin)
    FE->>FE: visual_workflow_builder.add_step("ai_agent", claude_agent)
    FE->>FE: visual_workflow_builder.connect_steps()
    U->>FE: Save workflow
    FE->>API: POST /api/v1/workflows
    
    API->>DB: INSERT INTO workflows (user_id, name, description, config)
    DB-->>API: Workflow record created
    API-->>FE: 201 Created {workflow_id}
    
    U->>FE: Execute workflow
    FE->>API: POST /api/v1/workflows/{id}/execute
    API->>WE: execute_workflow(workflow_definition, user_id)
    WE->>WE: create_execution_context(workflow_id, user_id)
    WE->>DB: INSERT INTO workflow_executions (workflow_id, status, started_at)
    DB-->>WE: Execution record created
    
    %% Workflow Step Execution
    WE->>WE: build_dependency_graph(steps)
    WE->>WE: execute_steps_batch(ready_steps)
    
    %% Step 1: Plugin Action
    WE->>PE: execute_plugin_action("canvas-integration", "get_assignments", params)
    PE->>CP: get_assignments(due_within_days=7)
    CP-->>PE: List[Assignment] (upcoming assignments)
    PE-->>WE: PluginExecutionResult(assignments_data)
    
    %% Step 2: AI Agent Processing
    WE->>WE: interpolate_variables(prompt_template, context)
    WE->>AO: execute_single_agent("claude", analysis_request)
    AO->>MA: process(AgentRequest with assignments data)
    MA->>MA: analyze_assignments_and_prioritize(assignments)
    MA-->>AO: AgentResponse(priority_analysis)
    AO-->>WE: AgentResponse
    
    %% Step 3: System Action
    WE->>WE: execute_system_step("create_notification")
    WE->>DB: INSERT INTO notifications (user_id, title, content, priority)
    DB-->>WE: Notification created
    
    WE->>DB: UPDATE workflow_executions SET status='completed', results=?, completed_at=NOW()
    WE-->>API: execution_id
    API-->>FE: 202 Accepted {execution_id, status: "running"}
    
    %% Real-time Status Updates
    FE->>API: GET /api/v1/workflows/executions/{id}/status (polling)
    API->>WE: get_execution_status(execution_id)
    WE->>DB: SELECT * FROM workflow_executions WHERE id=?
    DB-->>WE: Execution record
    WE-->>API: ExecutionStatus(completed, results)
    API-->>FE: 200 OK {status: "completed", results}
    FE->>U: Display "Workflow completed successfully"

    %% Resource Management
    Note over U, MA: Resource Upload and Organization
    U->>FE: Drag and drop PDF file
    FE->>FE: prepare_chunked_upload(file)
    loop For each chunk
        FE->>API: POST /api/v1/upload/chunk
        API->>API: save_chunk_to_temp_storage(chunk)
        API-->>FE: 200 OK {chunk_index, checksum}
    end
    
    FE->>API: POST /api/v1/upload/complete
    API->>API: assemble_chunks_to_final_file(chunks)
    API->>API: extract_metadata_and_content(file)
    
    %% AI-powered content analysis
    API->>AO: execute_single_agent("claude", document_analysis_request)
    AO->>MA: process(AgentRequest with document content)
    MA->>MA: analyze_document_content(content)
    MA-->>AO: AgentResponse(summary, tags, topics)
    AO-->>API: AgentResponse
    
    API->>DB: INSERT INTO resources (user_id, title, type, file_path, ai_summary, tags)
    DB-->>API: Resource record created
    
    %% Auto-association with courses
    API->>API: find_related_courses_and_topics(tags, content)
    loop For each related entity
        API->>DB: INSERT INTO resource_associations (resource_id, course_id, topic_id)
        DB-->>API: Association created
    end
    
    API->>Cache: invalidate_pattern("resources:user_123*")
    API-->>FE: 201 Created {resource_info, ai_analysis}
    FE->>U: Display "File uploaded and analyzed successfully"

    %% Search and Discovery
    Note over U, MA: Intelligent Search
    U->>FE: Search for "machine learning algorithms"
    FE->>API: GET /api/v1/resources/search?q="machine learning algorithms"
    API->>Cache: get("search:user_123:machine_learning_algorithms")
    Cache-->>API: null (cache miss)
    
    API->>DB: SELECT * FROM resources WHERE user_id=? AND search_vector @@ plainto_tsquery(?)
    DB-->>API: List[Resource] (text matches)
    
    %% Semantic search enhancement
    API->>AO: execute_single_agent("embedding_agent", semantic_search_request)
    AO->>MA: generate_embeddings(query)
    MA-->>AO: AgentResponse(query_embedding)
    AO-->>API: Query embeddings
    
    API->>DB: SELECT * FROM resources WHERE user_id=? ORDER BY embedding <-> ? LIMIT 10
    DB-->>API: List[Resource] (semantic matches)
    
    API->>API: merge_and_rank_results(text_matches, semantic_matches)
    API->>Cache: set("search:user_123:machine_learning_algorithms", results, ttl=300)
    API-->>FE: 200 OK {results, total_count}
    FE->>FE: render_search_results(results)
    FE->>U: Display search results with relevance scores

    %% Error Handling and Recovery
    Note over U, MA: Error Scenarios
    U->>FE: Execute workflow with invalid plugin
    FE->>API: POST /api/v1/workflows/{id}/execute
    API->>WE: execute_workflow(workflow_definition, user_id)
    WE->>PE: execute_plugin_action("invalid-plugin", "action", params)
    PE-->>WE: PluginExecutionResult(success=false, error="Plugin not found")
    WE->>WE: handle_step_failure(step, error)
    WE->>WE: retry_step_with_backoff(step, retry_count)
    WE->>WE: max_retries_exceeded()
    WE->>DB: UPDATE workflow_executions SET status='failed', error_message=?
    WE-->>API: ExecutionResult(failed, error_details)
    API-->>FE: 200 OK {status: "failed", error: "Plugin execution failed"}
    FE->>FE: display_error_notification(error)
    FE->>U: Show error message with retry option

    %% Session Management and Cleanup
    Note over U, MA: Session Lifecycle
    FE->>FE: token_expiry_check()
    FE->>API: POST /api/v1/auth/refresh
    API->>Auth: verify_refresh_token(refresh_token)
    Auth->>DB: SELECT refresh_tokens WHERE token=? AND expires_at > NOW()
    DB-->>Auth: Token record
    Auth->>Auth: create_new_access_token(user_data)
    Auth->>Auth: rotate_refresh_token(old_token)
    Auth->>DB: UPDATE refresh_tokens SET token=?, expires_at=?
    Auth-->>API: TokenResponse(new_access_token, new_refresh_token)
    API-->>FE: 200 OK {tokens}
    FE->>FE: update_stored_tokens(tokens)
    
    U->>FE: Logout
    FE->>API: POST /api/v1/auth/logout
    API->>Auth: invalidate_tokens(access_token, refresh_token)
    Auth->>Cache: set("blacklisted_token:{token_id}", true, ttl=token_expiry)
    Auth->>DB: DELETE FROM refresh_tokens WHERE token=?
    Auth-->>API: Success
    API-->>FE: 200 OK
    FE->>FE: clear_stored_tokens()
    FE->>U: Redirect to login page